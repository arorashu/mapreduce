# mapreduce

This is a go package(/ library) `mapreduce` that allows you to write MapReduce code by just providing:

1. a `map` function
2. a `reduce` function
3. list of input files
4. no of reducers (`nReduce`)

The library automatically creates parallel mapper workers for each input file, and `nReduce` number of parallel reduce worker. The output of all the reducers is merged and written to single file.

A few sample text files from Project gutenberg are placed in the `data/gutenberg` folder.


## How to Run

1. `$ cd src/go`
2. Export current directory to GOPATH using below template 
  
    `$ export GOPATH=${CUR_DIR}`

3. Run Map reduce job, an example is given in `wc.go`, which can be run as:

    `$ go run wc.go master sequential x1.txt .. xN.txt`
  
4. The output will be contained in the file: `mrtmp.wcseq`


## Word count example

Here's a simple example for calculating word count from files.

Mapper function:

```go
// The mapping function is called once for each piece of the input.
// In this framework, the key is the name of the file that is being processed,
// and the value is the file's contents. The return value should be a slice of
// key/value pairs, each represented by a mapreduce.KeyValue.
func mapF(document string, value string) (res []mapreduce.KeyValue) {
	var kvArr []mapreduce.KeyValue
  // split words according to this condition
	wordsArray := strings.FieldsFunc(value, func(c rune) bool {
		return !unicode.IsLetter(c) && !unicode.IsNumber(c)
	})

	for _, key := range wordsArray {
		kvArr = append(kvArr, mapreduce.KeyValue{key, "1"})
	}

	return kvArr
}
```

and the corresponding reduce function:

```go
// The reduce function is called once for each key generated by Map, with a
// list of that key's string value (merged across all inputs). The return value
// should be a single output value for that key.
func reduceF(key string, values []string) string {
	// todo: you also have to write this function

	sum := 0
	for _, value := range values {
		count, err := strconv.Atoi(value)
		if err != nil {
			println("error converting to int")
		}
		sum += count
	}

	return strconv.Itoa(sum)
}

```

Then, the package can be invoked by:

```go
mr = mapreduce.Sequential(jobName, files, nReduce, mapF, reduceF)
```

For a jobName = `wcjob`, the output will be stored in the filename = `mrtmp.wcjob`


## References: 

1. MapReduce [paper](https://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf)
2. BU CS651 starter [code](https://cs-people.bu.edu/liagos/451/labs/lab-1.html)
